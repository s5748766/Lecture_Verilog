# ğŸ§© Digilent Basys3 Verilog ì‘ìš©íšŒë¡œ ëª¨ë¸ë§

## ğŸ¯ í•™ìŠµëª©í‘œ
- ë””ì§€í„¸ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ì ì¸ **ì‘ìš©íšŒë¡œ**ë¥¼ ì´í•´í•œë‹¤.  
- **í‘¸ì‹œë²„íŠ¼ ë””ë°”ìš´ìŠ¤** ì…ë ¥íšŒë¡œë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  
- **Text LCD**ë¥¼ ì œì–´í•˜ëŠ” ì¶œë ¥íšŒë¡œë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  
- ëŒ€í‘œì  ì§ë ¬ í†µì‹ ì¸ **UART** íšŒë¡œë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  
- ê°„ë‹¨í•œ **ë””ì§€í„¸ í•„í„°**(FIR/IIR)ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.  

---

## ğŸ“š ëª©ì°¨
1. [í‘¸ì‹œë²„íŠ¼ì„ ì´ìš©í•œ ì…ë ¥íšŒë¡œ](#1-í‘¸ì‹œë²„íŠ¼ì„-ì´ìš©í•œ-ì…ë ¥íšŒë¡œ)  
2. [í…ìŠ¤íŠ¸ LCD](#2-í…ìŠ¤íŠ¸-lcd)  
3. [UART í†µì‹ ](#3-uart-í†µì‹ )  
4. [ë””ì§€í„¸ í•„í„°](#4-ë””ì§€í„¸-í•„í„°)  

---

## 1. í‘¸ì‹œë²„íŠ¼ì„ ì´ìš©í•œ ì…ë ¥íšŒë¡œ

### â–¶ ìŠ¤ìœ„ì¹˜ì™€ ë””ë°”ìš´ì‹±
- ìŠ¤ìœ„ì¹˜ëŠ” on/offë¥¼ í†µí•´ ë””ì§€í„¸ ì…ë ¥ì„ ì œê³µí•˜ì§€ë§Œ **chattering/bounce**ë¡œ ì¸í•´ ì§§ì€ ì‹œê°„ë™ì•ˆ 0/1ì´ ë¹ ë¥´ê²Œ í”ë“¤ë¦°ë‹¤.  
- **ë””ë°”ìš´ì‹±**ì€ ì´ ê³ ì£¼íŒŒ ì¡ìŒì„ ì œê±°í•˜ëŠ” ì²˜ë¦¬ë¡œ, HW(ì•„ë‚ ë¡œê·¸ LPF/Schmitt) ë˜ëŠ” **ë””ì§€í„¸(ìƒ˜í”Œë§+FF)** ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.

### ğŸ’¡ ì•„ì´ë””ì–´
- ëŠë¦° ìƒ˜í”Œí´ë¡(ì˜ˆ: 10Hz)ìœ¼ë¡œ ìŠ¤ìœ„ì¹˜ë¥¼ **ë‘ ë²ˆ ìƒ˜í”Œ** â†’ `q1`, `q2`  
- **ìƒìŠ¹ì—£ì§€ ê²€ì¶œ**: `single_pulse = q1 & ~q2`  
- í•„ìš” ì‹œ ì‹œìŠ¤í…œ í´ë¡ í•œ ì£¼ê¸°ì˜ **ì‹±í¬ í„ìŠ¤**ë¡œ ë‹¤ì‹œ í˜•ì„±

### ğŸ’» ë‹¨ì¼ í„ìŠ¤ ë””ë°”ìš´ì„œ (ê²Œì´íŠ¸/êµ¬ì¡°ì )
```verilog
// 50MHz -> 10Hz ë¶„ì£¼ê¸°
module freq_div_10hz(input iCLK, input iRESETn, output oMYCLK);
  localparam VAL_CNT = 22'd2_500_000; // 50MHz / (2*2.5M) = 10Hz í† ê¸€
  reg [21:0] cnt; reg myclk;
  assign oMYCLK = myclk;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; myclk<=1'b0; end
    else if(cnt==VAL_CNT-1) begin cnt<=0; myclk<=~myclk; end
    else cnt<=cnt+1'b1;
  end
endmodule

// ë¹„ë™ê¸° í´ë¦¬ì–´/í”„ë¦¬ì…‹ì„ ê°€ì§„ DFF (ì¶œë ¥ë§Œ ì‚¬ìš©)
module d_ff(input iCLK, input iCLEARn, input iPRESETn, input iD, output reg oQ, output oQn);
  assign oQn = ~oQ;
  always @(posedge iCLK or negedge iCLEARn or negedge iPRESETn) begin
    if(!iCLEARn)      oQ <= 1'b0;
    else if(!iPRESETn)oQ <= 1'b1;
    else              oQ <= iD;
  end
endmodule

// ë””ë°”ìš´ìŠ¤ + ë‹¨ì¼í„ìŠ¤ ì¶œë ¥
module debouncer(input iCLK, input iRESETn, input iSW, output oPULSE);
  wire slow; wire q1, qn2;
  freq_div_10hz UDIV(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(slow));
  d_ff U1(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(iSW), .oQ(q1));
  d_ff U2(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q1),  .oQ(), .oQn(qn2));
  assign oPULSE = q1 & qn2; // q1 & ~q2
endmodule
```

#### ğŸ§ª Testbench (3ì´ˆ êµ¬ë™)
```verilog
`timescale 1ns/1ns
module tb_debouncer;
  localparam TCLK = 20; // 50MHz
  reg iCLK, iRESETn, iSW; wire oPULSE;
  debouncer DUT(.iCLK(iCLK), .iRESETn(iRESETn), .iSW(iSW), .oPULSE(oPULSE));

  initial begin iCLK=0; forever #(TCLK/2) iCLK=~iCLK; end
  initial begin
    iRESETn=1; #(TCLK/2); iRESETn=0; #200; iRESETn=1;
    iSW=0;
    repeat(5) begin
      #(TCLK*30_000_000) iSW=~iSW; // 0.6s ê°„ê²©
    end
    #(TCLK*150_000_000); // ì´ 3s
    $stop;
  end
endmodule
```

### ğŸ’» ê¸°ì¤€ í´ë¡ ì£¼ê¸°ì˜ ì‹±í¬ í„ìŠ¤ ë§Œë“¤ê¸°
```verilog
module debouncer_clk(input iCLK, input iRESETn, input iSW, output oPULSE);
  wire slow; wire q1, qn2, q3, qn4;
  wire single_pulse;
  freq_div_10hz UDIV(.iCLK(iCLK), .iRESETn(iRESETn), .oMYCLK(slow));
  d_ff U1(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(iSW), .oQ(q1));
  d_ff U2(.iCLK(slow), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q1),  .oQ(), .oQn(qn2));
  assign single_pulse = q1 & qn2; // slow ë„ë©”ì¸

  // ì‹œìŠ¤í…œ í´ë¡ ë„ë©”ì¸ì—ì„œ 1í´ë¡ í„ìŠ¤ë¡œ ë™ê¸°í™”
  d_ff U3(.iCLK(iCLK), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(single_pulse), .oQ(q3));
  d_ff U4(.iCLK(iCLK), .iCLEARn(iRESETn), .iPRESETn(1'b1), .iD(q3),           .oQ(), .oQn(qn4));
  assign oPULSE = q3 & qn4; // 1 sys-clk pulse
endmodule
```

---

## 2. í…ìŠ¤íŠ¸ LCD

### â–¶ ê°œìš”
- ì¼ë°˜ì ì¸ **HD44780 í˜¸í™˜ 16x2 LCD**: `RS, RW, E, DATA[7:0]`  
- ì´ˆê¸°í™”(**Function Set, Display ON, Clear**) í›„ **ëª…ë ¹/ë°ì´í„°** ì „ì†¡  
- ë³¸ ì˜ˆì œëŠ” **ì“°ê¸° ì „ìš©(RW=0)**, 8-bit ëª¨ë“œ, ê°„ë‹¨í•œ **FSM**ìœ¼ë¡œ "HELLO" ì¶œë ¥

### ğŸ’» LCD ì´ë‹ˆì…œë¼ì´ì € & â€œHELLOâ€ ì¶œë ¥ (50MHz ê¸°ì¤€)
```verilog
module lcd_hello(
  input iCLK, input iRESETn,
  output RS, output RW, output E, output [7:0] DATA
);
  // RW ê³ ì • 0 (Write only)
  assign RW = 1'b0;

  // ê°„ë‹¨ íƒ€ì´ë¨¸(Enable í„ìŠ¤ì™€ ëª…ë ¹ ì§€ì—°ìš©)
  reg [19:0] tcnt; // ~20msê¹Œì§€ í™•ë³´(50MHz ê¸°ì¤€)
  wire tick = (tcnt==20'd0);
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) tcnt <= 20'd999_999; // ì´ˆê¸° ì§€ì—°
    else tcnt <= (tcnt==0) ? 20'd50_000 : tcnt-1; // 1ms tick
  end

  // FSM
  typedef enum reg [3:0] {
    S_IDLE=0, S_FUNCSET, S_DISPON, S_CLEAR, S_ENTRY, S_SETADDR,
    S_H, S_E, S_L1, S_L2, S_O, S_DONE
  } st_t;
  st_t cs, ns;

  reg [7:0] data; reg rs; reg e;
  assign RS = rs; assign E = e; assign DATA = data;

  // Enable í„ìŠ¤ (ê°„ë‹¨í™”: tickë§ˆë‹¤ í† ê¸€)
  reg [1:0] ep;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) ep<=0;
    else if(tick) ep <= ep + 1'b1;
  end
  always @* e = (ep==2'b01); // ì§§ì€ í„ìŠ¤

  // ìƒíƒœì²œì´
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) cs<=S_IDLE; else if(tick) cs<=ns;
  end

  always @* begin
    ns = cs;
    rs = 1'b0; data = 8'h00;
    case(cs)
      S_IDLE:     ns = S_FUNCSET;
      S_FUNCSET:  begin data=8'b0011_1000; ns = S_DISPON; end // 8bit, 2line, 5x8
      S_DISPON:   begin data=8'b0000_1100; ns = S_CLEAR;  end // Display ON
      S_CLEAR:    begin data=8'b0000_0001; ns = S_ENTRY;  end // Clear
      S_ENTRY:    begin data=8'b0000_0110; ns = S_SETADDR;end // Entry mode
      S_SETADDR:  begin data=8'b1000_0000; ns = S_H;      end // DDRAM addr 0
      S_H:        begin rs=1; data="H"; ns = S_E; end
      S_E:        begin rs=1; data="E"; ns = S_L1; end
      S_L1:       begin rs=1; data="L"; ns = S_L2; end
      S_L2:       begin rs=1; data="L"; ns = S_O; end
      S_O:        begin rs=1; data="O"; ns = S_DONE; end
      S_DONE:     begin rs=1; data=" "; ns = S_DONE; end
    endcase
  end
endmodule
```

#### ğŸ§ª ê°„ë‹¨ Testbench (íŒŒí˜• í™•ì¸ìš©)
```verilog
`timescale 1us/1ns
module tb_lcd_hello;
  reg iCLK, iRESETn; wire RS,RW,E; wire [7:0] DATA;
  lcd_hello DUT(.iCLK(iCLK), .iRESETn(iRESETn), .RS(RS), .RW(RW), .E(E), .DATA(DATA));
  initial iCLK=0; always #0.01 iCLK=~iCLK; // 50MHz ê·¼ì‚¬
  initial begin
    iRESETn=0; #100; iRESETn=1;
    #50_000; // 50 ms ê´€ì°°
    $stop;
  end
endmodule
```

> ì‹¤ì œ LCD ëª¨ë“ˆì— ë”°ë¼ ì´ˆê¸° ì§€ì—°/í„ìŠ¤ í­ì„ ë” ëŠ˜ë ¤ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. PMOD ì¸í„°í˜ì´ìŠ¤ ì—°ê²° í•€ë§µì€ ë³´ë“œ ë§¤ë‰´ì–¼ì„ ì°¸ê³ í•˜ì„¸ìš”.

---

## 3. UART í†µì‹ 

### â–¶ ê°œìš”
- **UART TX/RX**: ë¹„íŠ¸ íƒ€ì´ë°ì— ë§ì¶° **ìŠ¤íƒ€íŠ¸(0) â†’ ë°ì´í„° 8bit â†’ ìŠ¤í†±(1)** ì „ì†¡/ìˆ˜ì‹   
- íŒŒë¼ë¯¸í„°: `CLK_FREQ`, `BAUD`ë¡œ **ë¶„ì£¼ê°’** ê³„ì‚°

### ğŸ’» íŒŒë¼ë¯¸í„°í™”ëœ UART TX/RX (8N1)
```verilog
module uart_baudgen #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, output reg tick);
  localparam DIV = CLK_FREQ/BAUD;
  reg [$clog2(DIV)-1:0] cnt;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin cnt<=0; tick<=1'b0; end
    else if(cnt==DIV-1) begin cnt<=0; tick<=1'b1; end
    else begin cnt<=cnt+1'b1; tick<=1'b0; end
  end
endmodule

module uart_tx #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, input [7:0] iDATA, input iVALID, output reg oREADY,
  output reg oTX);
  reg [3:0] bitpos; reg [9:0] sh; wire tick;
  uart_baudgen #(.CLK_FREQ(CLK_FREQ),.BAUD(BAUD)) BG(.iCLK(iCLK),.iRESETn(iRESETn),.tick(tick));
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin oTX<=1'b1; oREADY<=1'b1; bitpos<=0; sh<=10'h3FF; end
    else if(oREADY && iVALID) begin
      sh <= {1'b1, iDATA, 1'b0}; // stop, data[7:0], start
      bitpos<=0; oREADY<=1'b0;
    end
    else if(!oREADY && tick) begin
      oTX <= sh[0]; sh <= {1'b1, sh[9:1]}; bitpos <= bitpos + 1'b1;
      if(bitpos==4'd9) oREADY<=1'b1;
    end
  end
endmodule

module uart_rx #(parameter CLK_FREQ=50_000_000, BAUD=115200)
 (input iCLK, input iRESETn, input iRX, output reg [7:0] oDATA, output reg oVALID);
  localparam DIV = CLK_FREQ/BAUD;
  reg [15:0] cnt; reg [3:0] bitpos; reg busy; reg rx_d;
  // 1x ìƒ˜í”Œë§(ê°€ìš´ë° ìƒ˜í”Œ) â€“ ê°„ë‹¨ ë²„ì „
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin busy<=0; cnt<=0; bitpos<=0; oVALID<=0; end
    else begin
      oVALID<=0; rx_d<=iRX;
      if(!busy) begin
        if(rx_d==1'b0) begin busy<=1; cnt<=DIV+(DIV/2); bitpos<=0; end // start ê²€ì¶œ í›„ 1.5ë¹„íŠ¸ ì§€ì—°
      end else begin
        if(cnt==0) begin
          cnt<=DIV;
          if(bitpos<8) oDATA <= {rx_d, oDATA[7:1]}; // LSB first
          bitpos <= bitpos + 1'b1;
          if(bitpos==8) begin // stop
            oVALID<=1; busy<=0;
          end
        end else cnt<=cnt-1;
      end
    end
  end
endmodule
```

#### ğŸ§ª Loopback Testbench
```verilog
`timescale 1ns/1ps
module tb_uart;
  localparam CLK=50_000_000, BAUD=115200;
  reg clk, rstn; reg [7:0] din; reg valid; wire ready; wire tx; wire [7:0] dout; wire vld;
  uart_tx #(.CLK_FREQ(CLK),.BAUD(BAUD)) TX(.iCLK(clk),.iRESETn(rstn),.iDATA(din),.iVALID(valid),.oREADY(ready),.oTX(tx));
  uart_rx #(.CLK_FREQ(CLK),.BAUD(BAUD)) RX(.iCLK(clk),.iRESETn(rstn),.iRX(tx),.oDATA(dout),.oVALID(vld));
  initial clk=0; always #10 clk=~clk; // 50MHz
  initial begin
    rstn=0; valid=0; din=8'h00; #200; rstn=1;
    repeat(5) begin
      @(posedge clk); din=$random; valid=1; @(posedge clk); valid=0;
      wait(vld==1);  // ìˆ˜ì‹  ì™„ë£Œ
    end
    $stop;
  end
endmodule
```

> ì‹¤ì‚¬ìš© ì‹œëŠ” **ì˜¤ë²„ìƒ˜í”Œë§(16x)**, í”„ë ˆì´ë°/íŒ¨ë¦¬í‹° ì—ëŸ¬ ê²€ì¶œ ë“±ì„ ì¶”ê°€í•˜ì„¸ìš”.

---

## 4. ë””ì§€í„¸ í•„í„°

### â–¶ ê°œìš”
- **FIR(ìœ í•œ ì„í„ìŠ¤ ì‘ë‹µ)**: ê³ ì • ê³„ìˆ˜ì™€ ì§€ì—°ì„ ìœ¼ë¡œ êµ¬ì„±, í•­ìƒ ì•ˆì •ì   
- **IIR(ë¬´í•œ ì„í„ìŠ¤ ì‘ë‹µ)**: í”¼ë“œë°± í¬í•¨, ì ì€ íƒ­ìœ¼ë¡œ ë‚ ì¹´ë¡œìš´ ì‘ë‹µ ê°€ëŠ¥

### ğŸ’» FIR: 4-íƒ­ ì´ë™í‰ê·  í•„í„° (8-bit â†’ 8-bit)
```verilog
module fir_movavg4(input iCLK, input iRESETn, input [7:0] iX, output [7:0] oY);
  reg [7:0] d1,d2,d3; reg [9:0] sum; // ìµœëŒ€ 4*255=1020 -> 10bit
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin d1<=0; d2<=0; d3<=0; sum<=0; end
    else begin
      sum <= iX + d1 + d2 + d3;
      d3 <= d2; d2 <= d1; d1 <= iX;
    end
  end
  assign oY = sum[9:2]; // /4
endmodule
```

### ğŸ’» IIR: 1ì°¨ ì €ì—­í†µê³¼(ê³ ì •ì†Œìˆ˜ì  â€“ Î±=1/8)
```verilog
module iir_lp1 #(parameter ALPHA_SHIFT=3) // y[n]=y[n-1]+(x[n]-y[n-1])*(1/2^s)
 (input iCLK, input iRESETn, input [7:0] iX, output reg [7:0] oY);
  reg [10:0] acc;
  always @(posedge iCLK or negedge iRESETn) begin
    if(!iRESETn) begin oY<=0; acc<=0; end
    else begin
      acc <= {{3{1'b0}}, oY} + ({{3{1'b0}}, iX} - {{3{1'b0}}, oY}) >> ALPHA_SHIFT;
      oY  <= acc[7:0];
    end
  end
endmodule
```

#### ğŸ§ª ê°„ë‹¨ Testbench (ì„í„ìŠ¤/ìŠ¤í… ì‘ë‹µ ê´€ì°°)
```verilog
`timescale 1ns/1ps
module tb_filters;
  reg clk, rstn; reg [7:0] x; wire [7:0] yfir, yiir;
  fir_movavg4 FIR(.iCLK(clk), .iRESETn(rstn), .iX(x), .oY(yfir));
  iir_lp1     IIR(.iCLK(clk), .iRESETn(rstn), .iX(x), .oY(yiir));
  initial clk=0; always #10 clk=~clk;
  integer i;
  initial begin
    rstn=0; x=0; #100; rstn=1;
    // ì„í„ìŠ¤ ì…ë ¥
    x=8'd255; #20; x=0; #200;
    // ìŠ¤í… ì…ë ¥
    x=8'd128; for(i=0;i<50;i=i+1) #20;
    $stop;
  end
endmodule
```

---

### âœ… ë§ˆë¬´ë¦¬ íŒ
- ì™¸ë¶€ ë””ë°”ì´ìŠ¤(LCD/UART)ëŠ” **ë°ì´í„°ì‹œíŠ¸ì˜ ì‹œê°„ìš”ê±´**(setup/hold, pulse width)ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì„¸ìš”.  
- í´ë¡ ë„ë©”ì¸ ê°„ ì‹ í˜¸ ì´ë™ ì‹œì—” **ë™ê¸°í™” FF** ë˜ëŠ” **CDC íšŒë¡œ**ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.  
- ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ë™ì‘ í™•ì¸ í›„, **í•€ ì œì•½(XDC)** ê³¼ **íƒ€ì´ë° ë¶„ì„**ì„ ì™„ë£Œí•˜ì„¸ìš”.
